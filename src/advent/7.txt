Signal 139629729
Sequence: A=9 B=8 C=7 D=6 E=5
Code: 3,26,1001,26,-4,26,3,27,1002,27,2,27,1,27,26,27,4,27,1001,28,-1,28,1005,28,6,99,0,0,5

The feedback loop produces this output for the first three iterations ([amplifier index 0-4, instruction pointer, array of state], then -reads value, +outputs value):

[0,0,[9,0]] -9 -0 +5
[1,0,[8,5]] -8 -5 +14
[2,0,[7,14]] -7 -14 +31
[3,0,[6,31]] -6 -31 +64
[4,0,[5,64]] -5 -64 +129

[0,18,[129]] -129 +258
[1,18,[258]] -258 +516
[2,18,[516]] -516 +1032
[3,18,[1032]] -1032 +2064
[4,18,[2064]] -2064 +4128

[0,18,[4128]] -4128 +8256
[1,18,[8256]] -8256 +16512
[2,18,[16512]] -16512 +33024
[3,18,[33024]] -33024 +66048
[4,18,[66048]] -66048 +132096

So:
- amplifier A took phase 9 and initial state 0, produced 5,
- B took phase 8 and A's output 5 and produced 14,
- and so on: C [7,14] -> 31,
- D [6,31] -> 64,
- E [5,64] -> 129.
- A [129] resumes from position 18 (right after the opcode 4, so from opcode 1001) and produces 258,
- B [258] resumes also from position 18, produces 516,
- and so on...

The problem is that this program effectively doubles whatever was produced and after only a few dozen iterations is outside int64 range. What did I do wrong here? This intcode computer worked fine for the previous tasks. I only modified it to be fully stateless: it takes the instructions, pointer to start from, and inputs. It immediately returns the output value on opcode 4. I can share the code, but I think that I missed something in the logic.

Read More

2

RustingSword

44d

You need to reuse state of each amplifier from previous loop, instead of resetting it to original state.

The initial state of amplifier A in second loop should be

[3, 26, 1001, 26, -4, 26, 3, 27, 1002, 27, 2, 27, 1, 27, 26, 27, 4, 27, 1001, 28, -1, 28, 1005, 28, 6, 99, 5, 5, 5]

And the correct output of A in the second loop is 263, not 258
